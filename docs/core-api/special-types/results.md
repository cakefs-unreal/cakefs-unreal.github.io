
## Overview
{{ src_loc_group('Results', 'CakeResults')}}

Result types are lightweight structs that wrap [Outcome](outcomes.md) types and provide various convenience functions. They are returned from functions that involve IO operations.

## IO Results

### CakeResultFileIO
This result type is returned from any IO operation function involving a file, and it wraps an [ECakeOutcomeFileIO](outcomes.md#ecakeoutcomefileio) outcome value.

### CakeResultDirIO
This result type is returned from any IO operation function involving a directory, and it wraps an [ECakeOutcomeDirIO](outcomes.md#ecakeoutcomedirio) outcome value.

### Common Form 
Both IO result types have an extremely similar design and interface. The only meaningful difference is the outcome member field in each struct, which will hold values associated with the relevant IO operations. This field is named `Outcome` on both structs:

=== "C++"

	```c++ hl_lines="4 13"
	struct FCakeResultFileIO
	{
		/** The outcome value generated by the file IO operation associated with this result. */
		ECakeOutcomeFileIO Outcome{ ECakeOutcomeFileIO::NoOp };

		// ...
	};

	struct FCakeResultDirIO
	{

		/** The outcome value generated by the directory IO operation associated with this result. */
		ECakeOutcomeDirIO Outcome{ ECakeOutcomeDirIO::NoOp };

		// ...
	};
	```
=== "Blueprint"
	{{bp_img_results('File And Dir Results')}}

### Building IO Results

=== "C++"
	Result types have a default constructor, which will create a Result type that by default holds a `NoOp` outcome value:

	```c++
	FCakeResultFileIO DefaultResultFile{}; // => ECakeOutcomeFileIO::NoOp
	FCakeResultDirIO  DefaultResultDir {}; // => ECakeOutcomeDirIO::NoOp
	```

	We can set the desired outcome value in directly via the constructor:

	```c++
	FCakeResultFileIO ResultFile{ ECakeOutcomeFileIO::Ok };
	FCakeResultDirIO ResultDir{ ECakeOutcomeDirIO::Ok };
	```

	There also exist convenience static functions for each value of the associated outcome value that we can use instead:

	```c++
	FCakeResultFileIO ResultFile{ FCakeResultFileIO::Ok() };
	FCakeResultDirIO ResultDir{ FCakeResultDirIO::Ok() };
	```

	These can be especially helpful for more readable return values from functions that return the Result types:

	```c++ hl_lines="4"
	FCakeResultFileIO ReadFile()
	{
		// ...
		return FCakeResultFileIO::Ok();
	}
	```

=== "Blueprint"
	Building a result type is simple, we just need to use the appropriate make function and select the desired outcome value the result should hold.

	{{bp_img_results('File And Dir Build')}}

When writing functions that return Result types, we will encounter scenarios when we want to return either an Ok or some error outcome if a particular operation succeeds or fails. We can use the `OkOrErr` static utility function for this, which accepts a `bool` indicating success/failure and an outcome value that represents the error that has occurred if the operation failed. If the `bool` argument is true, then a Result type with an `Ok` outcome is created; otherwise, a Result type with the outcome argument is created instead.

=== "C++"
	```c++
	FCakeResultFileIO ResultOkFile{ 
		FCakeResultFileIO::OkOrErr(true, ECakeOutcomeFileIO::DoesNotExist) }; // => Ok

	FCakeResultFileIO ResultDNEFile{ 
		FCakeResultFileIO::OkOrErr(false, ECakeOutcomeFileIO::DoesNotExist) }; // => DoesNotExist

	FCakeResultDirIO ResultOkDir{ 
		FCakeResultDirIO::OkOrErr(true, ECakeOutcomeDirIO::FailedDelete) }; // => Ok

	FCakeResultFileIO ResultFailedDeleteDir{ 
		FCakeResultDirIO::OkOrErr(false, ECakeOutcomeDirIO::FailedDelete) }; // => FailedDelete
	```

=== "Blueprint"
	{{bp_img_results('File And Dir Ok Or Err')}}

### Using IO Results
!!! note
	The the following examples use only a CakeResultFileIO object, but the usage for CakeResultDirIO is exactly the same.

Results have a minimal interface, offering just a few utility methods for common operations. Often callers will want to know if an error has occurred to determine if they should examine the outcome value in detail. For this purpose, we can use `IsOk`, which returns true if the outcome value is either `Ok` or `NoOp`, and returns false otherwise: 

=== "C++"

	```c++ hl_lines="2 15"
		FCakeResultFileIO ResultOkFile{ FCakeResultFileIO::Ok() };
		if (ResultOkFile.IsOk())
		{
			// ... We can proceed, no error occurred ...
		}
		else
		{
			switch (ResultOkFile.Outcome)
			{
				// ... Time to assess what error occurred ...
			}
		}
	```
	Result types also have `operator bool`, which is equivalent to calling `IsOk`:

	```c++ hl_lines="2 7"
	FCakeResultFileIO ResultOkFile{ FCakeResultFileIO::Ok() };
	if (ResultOkFile)
	{
		// ... We can proceed, no error occurred.
	}
	```

=== "Blueprint"
	{{bp_img_results('File Is Ok')}}

There are some situations where we might want to ensure that an operation actually occurred, and so we can use `IsOkStrict`, which only returns true if the outcome value is `Ok`:
=== "C++"
	```c++ hl_lines="2 7"
		FCakeResultFileIO ResultOkFile{ FCakeResultFileIO::Ok() };
		if (ResultOkFile.IsOkStrict())
		{
			// ... We can proceed, the operation actually was performed and it succeeded ...
		}
	```
=== "Blueprint"
	{{bp_img_results('File Is Ok Strict')}}

!!! note
    If you are unfamiliar with the differences between `Ok` and `NoOp`, please see [this section](outcomes.md#ok-and-no-op).

The Result types have `operator==` and `operator!=` defined, which just compare against the outcome values stored by each Result type:
=== "C++"

	```c++
		const bool bFileEqual    = (FCakeResultFileIO::Ok() == FCakeResultFileIO::Ok());  // => true
		const bool bFileNotEqual = (FCakeResultFileIO::Ok() != FCakeResultFileIO::Ok()); // => false
	```

=== "Blueprint"
	{{bp_img_results('File Result Equality')}}


Finally, there is a `ToString` convenience function, which generates a human-readable string of the Result's held outcome value:

=== "C++"

	```c++ hl_lines="7"
	auto LogOutcome = [](const FString& OutcomeStr) {
		UE_LOG(LogTemp, Warning, TEXT("Got outcome: [%s]"), *OutcomeStr)
	};

	FCakeResultFileIO ResultFile{ FCakeResultFileIO::Ok() };

	LogOutcome( ResultFile.ToString() );
	```

=== "Blueprint"
	{{bp_img_results('File Result To String')}}

## Directory Traversal Results
Directory traversal result types are returned from any CakeDir traversal function.

!!! note
    If you are not familiar with directory traversal, please read [this section](../directories.md#directory-traversal) first.

### CakeResultTraversal
This result wraps an [ECakeOutcomeTraversal](outcomes.md#ecakeoutcometraversal) outcome value and is returned from any unguarded or guarded traversal function. 

### CakeResultSearch
This result wraps an [ECakeOutcomeTraversal](outcomes.md#ecakeoutcometraversal) outcome value and is returned from any search traversal function.

### Common Form
As with IO result types, the traversal types have a similar design and interface. However, the usage patterns are a bit more divergent due to the differences in [traversal style](../directories.md#traversal-styles) behavior:

=== "C++"

	```c++
	struct FCakeResultTraversal
	{
		ECakeOutcomeTraversal Outcome{ ECakeOutcomeTraversal::DidNotLaunch };
	};

	struct FCakeResultSearch
	{
		ECakeOutcomeSearch Outcome{ ECakeOutcomeSearch::DidNotLaunch };
	};
	```
=== "Blueprint"
	{{bp_img_results('Result Traversal Search')}}

### Building Traversal Results

=== "C++"
We can use the default constructor to make a traversal result type, which will have the default outcome value of `DidNotLaunch`:

```c++
FCakeResultTraversal ResultDefaultTraversal{}; // => DidNotLaunch
FCakeResultSearch    ResultDefaultSearch{}; // => DidNotLaunch
```
!!! note
    For more information about the `DidNotLaunch` outcome value, see [this section](outcomes.md#did-not-launch)

We can construct a traversal result type by submitting the desired outcome value as an argument:
```c++
FCakeResultTraversal ResultTraversal{ ECakeOutcomeTraversal::Completed }; // => Completed
FCakeResultSearch    ResultSearch   { ECakeOutcomeSearch::Succeeded    }; // => Succeeded
```

There are static convenience functions for constructing a traversal result type for each value in their associated outcome type:

```c++
FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed()}; // => Completed
FCakeResultSearch    ResultSearch   { FCakeResultSearch::Succeeded()   }; // => Succeeded
```

These functions can help make returning these types a bit more ergonomic and readable:
```c++
FCakeResultTraversal GuardedTraversalOp()
{
	// ...
	return FCakeResultTraversal::Completed();
}

FCakeResultSearch SearchTraversalOp()
{
	// ...
	return FCakeResultSearch::Succeeded();
}
```
=== "Blueprint"
	{{bp_img_results('Result Traversal Search Build')}}

### Common Utility
Both `operator==` and `operator!=` are defined on traversal result types. The equality logic merely compares the two outcome values:
=== "C++"
	```c++
	const bool bAreEqualTraversal{ 
		FCakeResultTraversal::Completed() == FCakeResultTraversal::Completed() }; // => true
	const bool bAreNotEqualTraversal{ 
		FCakeResultTraversal::Completed() != FCakeResultTraversal::Completed() }; // => false

	const bool bAreEqualSearch{ 
		FCakeResultSearch::Succeeded() == FCakeResultSearch::Succeeded() }; // => true
	const bool bAreNotEqualSearch{ 
		FCakeResultSearch::Succeeded() != FCakeResultSearch::Succeeded() }; // => false
	```

=== "Blueprint"
	{{bp_img_results('Result Traversal Equality')}}

We can use `ToString` to get a human-readable string that represents the outcome value that a particular traversal result type currently holds:
=== "C++"
	```c++
	auto LogTraversalOutcome = [](const FString& OutcomeStr) {
		UE_LOG(LogTemp, Warning, TEXT("Got outcome: [%s]"), *OutcomeStr)
	};

	FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed()}; // => Completed
	FCakeResultSearch    ResultSearch   { FCakeResultSearch::Succeeded()   }; // => Succeeded

	LogTraversalOutcome(ResultTraversal.ToString());
	LogTraversalOutcome(ResultSearch.ToString());
	```
=== "Blueprint"
	{{bp_img_results('Result Traversal Search To String')}}

### Using FCakeResultTraversal
As mentioned earlier, this result type will be returned by both unguarded and guarded traversal styles.  

To check if the traversal completed successfully, we can use `WasCompleted`:
=== "C++"

	```c++ hl_lines="3"
	FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed() }; 

	if (ResultTraversal.WasCompleted())
	{
		// ...
	}
	```

	We can also use `operator bool` instead, which is equivalent to calling `WasCompleted`:

	```c++ hl_lines="3"
	FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed() }; 

	if (ResultTraversal)
	{
		// ...
	}
	```
=== "Blueprint"
	{{bp_img_results('Traversal Was Completed')}}

We can check for the other possible outcomes via `WasNotLaunched` and `WasAborted`:
=== "C++"

	```c++ hl_lines="3 7"
	FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed() }; 

	if (ResultTraversal.WasNotLaunched())
	{
		// ...
	}
	else if (ResultTraversal.WasAborted())
	{
		// ...
	}
	```
=== "Blueprint"
	{{bp_img_results('Traversal Outcome Shortcuts')}}

These are merely convenience functions that can enhance legibility in some situations, since we could have just branched on the outcome value contained in the result. Use whatever style you prefer.


!!! tip
    Remember, unguarded traversals will never return an `Aborted` outcome.

### Using FCakeResultSearch
This result type is only used in [search traversals](../directories.md#search-traversals). The important thing to remember is that we have a more complex way to define success and failure with search traversals via the [search outcome](outcomes.md#ecakeoutcomesearch) values. A search traversal can successfully run without errors but still fail if the search did not achieve its goal. 

To check if the search was a success, we can use `WasSuccessful`:

=== "C++"

	```c++ hl_lines="3"
	FCakeResultSearch ResultSearch{ FCakeResultSearch::Succeeded() }; 

	if (ResultSearch.WasSuccessful())
	{

	}
	```
	We can also use `operator bool` instead, which is equivalent to calling `WasSuccessful`:

	```c++ hl_lines="3"
	FCakeResultSearch ResultSearch{ FCakeResultSearch::Succeeded() }; 

	if (ResultSearch)
	{

	}
	```

=== "Blueprint"
	{{bp_img_results('Search Was Successful')}}

We can check if a search failed via `WasFailure`:

=== "C++"

	```c++ hl_lines="3"
	FCakeResultSearch ResultSearch{ FCakeResultSearch::Succeeded()}; 

	if (ResultSearch.WasFailure())
	{

	}
	```
=== "Blueprint"
	{{bp_img_results('Search Was Failure')}}

We can also check for the error outcomes via `WasAborted` and `WasNotLaunched`:

=== "C++"
	```c++ hl_lines="3 7"
	FCakeResultSearch ResultSearch{ FCakeResultSearch::Succeeded() }; 

	if (ResultSearch.WasNotLaunched())
	{
		// ...
	}
	else if (ResultSearch.WasAborted())
	{
		// ...
	}
	```
=== "Blueprint"
	{{bp_img_results('Search Outcome Shortcuts')}}

These are merely convenience functions that can enhance legibility in some situations. Since the outcome value is public we could have branched on the outcome value itself. Use whatever style you prefer.

## Advanced Results

### FCakeResultDirWork
FCakeResultDirWork is used extensively in [CakeMixLibrary](/core-api/cake-mix) functions. It wraps an [ECakeOutcomeDirWork](../outcomes/#ecakeoutcomedirwork) value and provides a minimal set of convenience functions. We will merely show the full set of convenience functions here, but understand that not all outcomes apply to every directory work operation. See [this section](/core-api/cake-mix/#directory-work-error-handling) for more details.

To check if the directory work operation completed successfully without any errors, we can use `WorkWasCompleted`:

=== "C++"
	```c++ hl_lines="5"
	FCakeResultDirWork DirWorkResult{ 
		ECakeOutcomeDirWork::WorkCompleted 
	};

	if (DirWorkResult.WorkWasCompleted())
	{
		// ...
	}

	```
=== "Blueprint"
	{{bp_img_results('Dir Work Work Was Completed')}}

To check if the directory work operation failed because the source directory did not exist, we can use `SourceDirDidNotExist`:

=== "C++"
	```c++ hl_lines="5"
	FCakeResultDirWork DirWorkResult{ 
		ECakeOutcomeDirWork::WorkCompleted 
	};

	if (DirWorkResult.SourceDirDidNotExist())
	{
		// ...
	}
	```
=== "Blueprint"
	{{bp_img_results('Dir Work Source Dir Did Not Exist')}}

To check if the directory work operation failed because the directory traversal could not launch, we can use `TraversalWasNotLaunched`:

=== "C++"
	```c++ hl_lines="5"
	FCakeResultDirWork DirWorkResult{ 
		ECakeOutcomeDirWork::WorkCompleted 
	};

	if (DirWorkResult.TraversalWasNotLaunched())
	{
		// ...
	}
	```
=== "Blueprint"
	{{bp_img_results('Dir Work Traversal Was Not Launched')}}

### FCakeResultBatchOp
This result type is used in the async exclusive [Batch Operation](/core-api/async-io/#batch-operations) functions. It wraps an [ECakeOutcomeBatchOp](outcomes.md#ecakeoutcomebatchop) value and provides a few utility functions. 

BatchOp outcomes can hold a NoOp value, and this indicates that the batch operation was skipped because the collection of items sent to it was empty. This means we have a meaningful distinction between Ok and NoOp, and thus we have both `IsOk` and `IsOkStrict` member functions we can use to distinguish between these events.

=== "C++"
	```c++ hl_lines="3 8"
		FCakeResultBatchOp BatchResult{ ECakeOutcomeBatchOp::Ok };

		if ( BatchResult.IsOk() )
		{
			// ... 
		}

		if ( BatchResult.IsOkStrict() )
		{
			// ...
		}
	```

=== "Blueprint"
	{{bp_img_results('Batch Op Is Ok')}}

Batch operations can be aborted early by the user supplied callback; thus we can also check to see if the batch operation was aborted:

=== "C++"

	```c++ hl_lines="3"
		FCakeResultBatchOp BatchResult{ ECakeOutcomeBatchOp::Ok };

		if ( BatchResult.WasAborted() )
		{
			// ... 
		}
	```

=== "Blueprint"
	{{bp_img_results('Batch Op Was Aborted')}}


Batch operations also contain a field that holds the number of items that were successfully processed during the operation. 

=== "C++"

	```c++ hl_lines="7"
	FCakeResultBatchOp BatchResult{ 
		ECakeOutcomeBatchOp::Ok 
	};

	UE_LOG(LogTemp, Warning, 
		TEXT("%d item(s) processed."), 
		BatchResult.TotalProcessed
	);
	```

=== "Blueprint"
	{{bp_img_results('Batch Op Total Processed')}}

There are two convenience functions we can do that involve the number of items processed. When we only want to know if at least one item was processed, we can use `DidAnyWork`. This will return true whenever the field `TotalProcessed` is greater than zero:

=== "C++"

	```c++ hl_lines="5"
	FCakeResultBatchOp BatchResult{ 
		ECakeOutcomeBatchOp::Ok 
	};

	if (BatchResult.DidAnyWork())
	{
		// ...
	}
	```

=== "Blueprint"
	{{bp_img_results('Batch Op Did Any Work')}}

There is an important nuance to consider with `DidAnyWork`: just because some work was done does not mean that the batch operation was completed without error. We can use the function `DidWorkWithoutErrors` which will return true only when the outcome result is `Ok` and `ItemsProcessed` is greater than zero. With this function, we can be sure that work was done and the batch operation was not aborted early due to any errors:

=== "C++"

	```c++ hl_lines="5"
	FCakeResultBatchOp BatchResult{ 
		ECakeOutcomeBatchOp::Ok 
	};

	if (BatchResult.DidWorkWithoutErrors())
	{
		// ...
	}
	```

=== "Blueprint"
	{{bp_img_results('Batch Op Did Work Without Errors')}}