--8<-- "note-native-only.md"

## Overview
{{ src_loc_group('Results', 'CakeResults')}}

Result types are lightweight structs that wrap [Outcome](outcomes.md) types and provide various convenience functions. They are returned from any C++ function that involves IO operations.

## IO Results

### FCakeResultFileIO
This result type is returned from any IO operation function involving a file, and it wraps an [ECakeOutcomeFileIO](outcomes.md#ecakeoutcomefileio) outcome value.

### FCakeResultDirIO
This result type is returned from any IO operation function involving a directory, and it wraps an [ECakeOutcomeDirIO](outcomes.md#ecakeoutcomedirio) outcome value.

### Common Form 
Both IO result types have an extremely similar design and interface. The only meaningful difference is the outcome member field in each struct, which will hold values associated with the relevant IO operations. This field is named `Outcome` on both structs:

```c++ hl_lines="4 13"
struct FCakeResultFileIO
{
	/** The outcome value generated by the file IO operation associated with this result. */
	ECakeOutcomeFileIO Outcome{ ECakeOutcomeFileIO::NoOp };

    // ...
};

struct FCakeResultDirIO
{

	/** The outcome value generated by the directory IO operation associated with this result. */
	ECakeOutcomeDirIO Outcome{ ECakeOutcomeDirIO::NoOp };

    // ...
};
```

### Building IO Results
Result types have a default constructor, which will create a Result type that by default holds a `NoOp` outcome value:

```c++
FCakeResultFileIO DefaultResultFile{}; // => ECakeOutcomeFileIO::NoOp
FCakeResultDirIO DefaultResultDir{}; // => ECakeOutcomeDirIO::NoOp
```

We can set the desired outcome value in directly via the constructor:
```c++
FCakeResultFileIO ResultFile{ ECakeOutcomeFileIO::Ok };
FCakeResultDirIO ResultDir{ ECakeOutcomeDirIO::Ok };
```

There also exist convenience static functions for each value of the associated outcome value that we can use instead:
```c++
FCakeResultFileIO ResultFile{ FCakeResultFileIO::Ok() };
FCakeResultDirIO ResultDir{ FCakeResultDirIO::Ok() };
```

These can be especially helpful for more readable return values from functions that return the Result types:
```c++ hl_lines="4"
FCakeResultFileIO ReadFile()
{
	// ...
	return FCakeResultFileIO::Ok();
}
```

When writing functions that return Result types, we will encounter scenarios when we want to return either an Ok or some error outcome if a particular operation succeeds or fails. We can use the `OkOrErr` static utility function for this, which accepts a `bool` indicating success/failure and an outcome value that represents the error that has occurred if the operation failed. If the `bool` argument is true, then a Result type with an `Ok` outcome is created; otherwise, a Result type with the outcome argument is created instead.
```c++
FCakeResultFileIO ResultOkFile{ 
    FCakeResultFileIO::OkOrErr(true, ECakeOutcomeFileIO::DoesNotExist) }; // => Ok

FCakeResultFileIO ResultDNEFile{ 
    FCakeResultFileIO::OkOrErr(false, ECakeOutcomeFileIO::DoesNotExist) }; // => DoesNotExist

FCakeResultDirIO ResultOkDir{ 
    FCakeResultDirIO::OkOrErr(true, ECakeOutcomeDirIO::FailedDelete) }; // => Ok

FCakeResultFileIO ResultFailedDeleteDir{ 
    FCakeResultDirIO::OkOrErr(false, ECakeOutcomeDirIO::FailedDelete) }; // => FailedDelete
```

### Using IO Results
Results have a minimal interface, offering just a few utility methods for common operations. Often callers will want to know if an error has occurred to determine if they should examine the outcome value in detail. For this purpose, we can use `IsOk`, which returns true if the outcome value is either `Ok` or `NoOp`, and returns false otherwise: 
```c++ hl_lines="2 15"
	FCakeResultFileIO ResultOkFile{ FCakeResultFileIO::Ok() };
	if (ResultOkFile.IsOk())
	{
		// ... We can proceed, no error occurred ...
	}
	else
	{
		switch (ResultOkFile.Outcome)
		{
			// ... Time to assess what error occurred ...
		}
	}

	FCakeResultDirIO ResultOkDir{ FCakeResultDirIO::Ok() };
	if (ResultOkDir.IsOk())
	{
		// ... We can proceed, no error occurred ...
	}
	else
	{
		switch (ResultOkDir.Outcome)
		{
			// ... Time to assess what error occurred ...
		}
	}
```
Result types also have `operator bool`, which is equivalent to calling `IsOk`:
```c++ hl_lines="2 7"
FCakeResultFileIO ResultOkFile{ FCakeResultFileIO::Ok() };
if (ResultOkFile)
{
    // ... We can proceed, no error occurred.
}
FCakeResultDirIO ResultOkDir{ FCakeResultDirIO::Ok() };
if (ResultOkDir)
{
    // ... We can proceed, no error occurred.
}
```
There are some situations where we might want to ensure that an operation actually occurred, and so we can use `IsOkStrict`, which only returns true if the outcome value is `Ok`:
```c++ hl_lines="2 7"
	FCakeResultFileIO ResultOkFile{ FCakeResultFileIO::Ok() };
	if (ResultOkFile.IsOkStrict())
	{
		// ... We can proceed, the operation actually was performed and it succeeded ...
	}
	FCakeResultDirIO ResultOkDir{ FCakeResultDirIO::Ok() };
	if (ResultOkDir.IsOkStrict())
	{
		// ... We can proceed, the operation actually was performed and it succeeded ...
	}
```
!!! note
    If you are unfamiliar with the differences between `Ok` and `NoOp`, please see [this section](outcomes.md#ok-and-no-op).

The Result types have `operator==` and `operator!=` defined, which just compare against the outcome values stored by each Result type:
```c++
	const bool bFileEqual    = (FCakeResultFileIO::Ok() == FCakeResultFileIO::Ok());  // => true
	const bool bFileNotEqual = (FCakeResultFileIO::Ok() != FCakeResultFileIO::Ok()); // => false
	
	const bool bDirEqual     = (FCakeResultDirIO::Ok() == FCakeResultDirIO::Ok());   // => true
	const bool bDirNotEqual  = (FCakeResultDirIO::Ok() != FCakeResultDirIO::Ok());  // => false
```

Finally, there is a `ToString` convenience function, which generates a human-readable string of the Result's held outcome value:

```c++
auto LogOutcome = [](const FString& OutcomeStr) {
    UE_LOG(LogTemp, Warning, TEXT("Got outcome: [%s]"), *OutcomeStr)
};

FCakeResultFileIO ResultFile{ FCakeResultFileIO::Ok() };
FCakeResultDirIO ResultDir{ FCakeResultDirIO::Ok() };

LogOutcome(ResultFile.ToString());
LogOutcome(ResultDir.ToString());
```

## Directory Traversal Results
Directory traversal result types are returned from any **FCakeDir** traversal function.

!!! note
    If you are not familiar with directory traversal, please read [this section](../directories.md#directory-traversal) first.

### FCakeResultTraversal
This result wraps an [ECakeOutcomeTraversal](outcomes.md#ecakeoutcometraversal) outcome value and is returned from any unguarded or guarded traversal function. 

### FCakeResultSearch
This result wraps an [ECakeOutcomeTraversal](outcomes.md#ecakeoutcometraversal) outcome value and is returned from any search traversal function.

### Common Form
As with IO result types, the traversal types have a similar design and interface. However, the usage patterns are a bit more divergent due to the differences in [traversal style](../directories.md#traversal-styles) behavior:

```c++
struct FCakeResultTraversal
{
	ECakeOutcomeTraversal Outcome{ ECakeOutcomeTraversal::DidNotLaunch };
};

struct FCakeResultSearch
{
	ECakeOutcomeSearch Outcome{ ECakeOutcomeSearch::DidNotLaunch };
};
```

### Building Traversal Results
We can use the default constructor to make a traversal result type, which will have the default outcome value of `DidNotLaunch`:

```c++
FCakeResultTraversal ResultDefaultTraversal{}; // => DidNotLaunch
FCakeResultSearch    ResultDefaultSearch{}; // => DidNotLaunch
```
!!! note
    For more information about the `DidNotLaunch` outcome value, see [this section](outcomes.md#did-not-launch)

We can construct a traversal result type by submitting the desired outcome value as an argument:
```c++
FCakeResultTraversal ResultTraversal{ ECakeOutcomeTraversal::Completed }; // => Completed
FCakeResultSearch    ResultSearch   { ECakeOutcomeSearch::Succeeded    }; // => Succeeded
```

There are static convenience functions for constructing a traversal result type for each value in their associated outcome type:

```c++
FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed()}; // => Completed
FCakeResultSearch    ResultSearch   { FCakeResultSearch::Succeeded()   }; // => Succeeded
```

These functions can help make returning these types a bit more ergonomic and readable:
```c++
FCakeResultTraversal GuardedTraversalOp()
{
	// ...
	return FCakeResultTraversal::Completed();
}

FCakeResultSearch SearchTraversalOp()
{
	// ...
	return FCakeResultSearch::Succeeded();
}
```
### Common Utility
Both `operator==` and `operator!=` are defined on traversal result types. The equality logic merely compares the two outcome values:
```c++
const bool bAreEqualTraversal{ 
    FCakeResultTraversal::Completed() == FCakeResultTraversal::Completed() }; // => true
const bool bAreNotEqualTraversal{ 
    FCakeResultTraversal::Completed() != FCakeResultTraversal::Completed() }; // => false

const bool bAreEqualSearch{ 
    FCakeResultSearch::Succeeded() == FCakeResultSearch::Succeeded() }; // => true
const bool bAreNotEqualSearch{ 
    FCakeResultSearch::Succeeded() != FCakeResultSearch::Succeeded() }; // => false
```

We can use `ToString` to get a human-readable string that represents the outcome value that a particular traversal result type currently holds:
```c++
auto LogTraversalOutcome = [](const FString& OutcomeStr) {
    UE_LOG(LogTemp, Warning, TEXT("Got outcome: [%s]"), *OutcomeStr)
};

FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed()}; // => Completed
FCakeResultSearch    ResultSearch   { FCakeResultSearch::Succeeded()   }; // => Succeeded

LogTraversalOutcome(ResultTraversal.ToString());
LogTraversalOutcome(ResultSearch.ToString());
```

### Using FCakeResultTraversal
As mentioned earlier, this result type will be returned by both unguarded and guarded traversal styles.  

To check if the traversal completed successfully, we can use `WasCompleted`:
```c++ hl_lines="3"
FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed()}; 

if (ResultTraversal.WasCompleted())
{
    // ...
}
```

We can also use `operator bool` instead, which is equivalent to calling `WasCompleted`:

```c++ hl_lines="3"
FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed()}; 

if (ResultTraversal)
{
    // ...
}
```

We can check for the other possible outcomes via `WasNotLaunched` and `WasAborted`:

```c++ hl_lines="3 7"
FCakeResultTraversal ResultTraversal{ FCakeResultTraversal::Completed()}; 

if (ResultTraversal.WasNotLaunched())
{
    // ...
}
else if (ResultTraversal.WasAborted())
{
    // ...
}
```

These are merely convenience functions that can enhance legibility in some situations. Since the outcome value is public we could have branched on the outcome value itself. Use whatever style you prefer.

!!! tip
    Remember, unguarded traversals will never return an `Aborted` outcome.

### Using FCakeResultSearch
This result type is only used in [search traversals](../directories.md#search-traversals). The important thing to remember is that we have a more complex way to define success and failure with search traversals via the [search outcome](outcomes.md#ecakeoutcomesearch) values. A search traversal can successfully run without errors but still fail if the search did not achieve its goal. 

To check if the search was a success, we can use `WasSuccessful`:

```c++ hl_lines="3"
FCakeResultSearch ResultSearch{ FCakeResultSearch::Succeeded()}; 

if (ResultSearch.WasSuccessful())
{

}
```
We can also use `operator bool` instead, which is equivalent to calling `WasSuccessful`:

```c++ hl_lines="3"
FCakeResultSearch ResultSearch{ FCakeResultSearch::Succeeded()}; 

if (ResultSearch)
{

}
```

We can check if a search failed via `WasFailure`:
```c++ hl_lines="3"
FCakeResultSearch ResultSearch{ FCakeResultSearch::Succeeded()}; 

if (ResultSearch.WasFailure())
{

}
```

We can also check for the error outcomes via `WasAborted` and `WasNotLaunched`:

```c++ hl_lines="3 7"
FCakeResultSearch ResultSearch{ FCakeResultSearch::Succeeded() }; 

if (ResultSearch.WasNotLaunched())
{
    // ...
}
else if (ResultSearch.WasAborted())
{
    // ...
}
```
These are merely convenience functions that can enhance legibility in some situations. Since the outcome value is public we could have branched on the outcome value itself. Use whatever style you prefer.

## Advanced Results

### FCakeResultDirWork
FCakeResultDirWork is used extensively in [CakeMixLibrary](/core-api/cake-mix) functions. It wraps an [ECakeOutcomeDirWork](../outcomes/#ecakeoutcomedirwork) value and provides a minimal set of convenience functions. For an overview of Directory Work operations, see [this section](/core-api/cake-mix/#directory-work-error-handling).

```c++
struct FCakeResultDirWork
{

	ECakeOutcomeDirWork Outcome{ ECakeOutcomeDirWork::WorkCompleted };

	FORCEINLINE [[nodiscard]] bool WorkWasCompleted() const
	{
		return Outcome == ECakeOutcomeDirWork::WorkCompleted;
	}

	FORCEINLINE [[nodiscard]] operator bool() const
	{
		return WorkWasCompleted();
	}

	//... Convenience constructors omitted
};
```

### FCakeResultBatchOp
This result type is used in the async exclusive [Batch Operation](/core-api/async-io/#batch-operations) functions. It wraps an [ECakeOutcomeBatchOp](outcomes.md#ecakeoutcomebatchop) value and provides a few utility functions. 

```c++
struct Cake IO_API FCakeResultBatchOp
{
	ECakeOutcomeBatchOp Outcome{ ECakeOutcomeBatchOp::NoOp };
	int32 TotalProcessed{ 0 };

	FORCEINLINE [[nodiscard]] bool IsOk() const
	{
		return CakeUtilities::Outcomes::IsOk(Outcome);
	}

	[[nodiscard]] operator bool() const
	{
		return IsOk();
	}

	FORCEINLINE [[nodiscard]] bool IsOkStrict() const
	{
		return CakeUtilities::Outcomes::IsOkStrict(Outcome);
	}

	FORCEINLINE [[nodiscard]] bool DidAnyWork() const { return TotalProcessed > 0; }
	FORCEINLINE [[nodiscard]] bool IsOkAndDidAnyWork() const { return IsOk() && DidAnyWork(); }
};
```
The standard Ok/NoOp/operator bool interfaces from other result types are here, but we have a few unique additions. The total number of elements processed by the batch operation are recorded in the member field `TotalProcessed`. We can use `DidAnyWork` to check if at least one element was processed by the batch operation. Please note that `DidAnyWork` does NOT imply that the batch operation was free from errors -- thus we can use the convenience function `IsOkAndDidAnyWork` to check for errors and ensure at least one item was processed in a single call.